//B24. Совершенные числа. Натуральное число называется совершенным, если оно равно сумме всех своих делителей, отличных от него самого. 
//Программа должна отыскивать совершенные числа, не превышающие заданное число.
//6 28 496 8128 33550336 8589869056 137438691328 (дальше не позволяет объем) (2305843008139952128)
//Код построен на утверждении Ферма(для эффективности)
#include <iostream>
#include <cmath>//библиотека для функции pow
using namespace std;
int main()
{
    cout << "Perfect numbers\n";
    long long int  n;//для переменной n выделяем наибольший объем (потому что значения совершенных чисел очень быстро возрастают)
    bool t = true;//вводим переменную для основного цикла
    while (t)
    {
        cout << "Input a positive integer>";
        while (!(cin >> n) || (cin.peek() != '\n') || n == 0 || n < 0)//если пользователь вводит неккоректные значения n
        // (отрицательные, ноль, символы или различные их комбинации(или слишком большие числа)), то его просят попробовать снова
        {
            cin.clear();
            while (cin.get() != '\n');
            cout << "You entered a non-correct value! Try entering the number again>";
        }
        if (n <= 6)//совершенных чисел меньше 6 не существует
        {
            cout << "There are no perfect numbers in this interval!";
        }
        else
        {
            int k = 1;//вводим счетчик для степени и присваиваем ему единицу(если пользователь решил продолжить, то счетчик сбрасывается до 1)
            cout << "Perfect numbers:";
            do//используем цикл do-while, чтобы было удобнее проверять условие в конце
            {
                long long int S = 0;//в начале каждого цикла счетчик обнуляется, если в него были записаны какие-либо делители
                long long int p = pow(2, k + 1) - 1;//(число уже является нечетным!) Если число p(по данной формуле) является простым, то
                long long int c = pow(2, k) * p;// число n будет являться совершенным(по теореме Ферма из теории чисел)
                for (int i = 3; i * i <= p; i += 2)//перебираем все нечетные делители(т.к. число p нечётное, 
                //то не имеет смысла брать 2 и остальные чётные числа (4, 6, 8... и т.д.)
                {
                    if (p % i == 0)
                    {
                        S += i;//если находим хотя бы один делитель, то записываем его в счетчик суммы делителей
                    }
                }
                if (S == 0)//если сумма осталась равна нулю, значит число p было простым(просто выписываем уже посчитанное по формуле Ферма 
                //совершенное число c)
                {
                    cout << "  " << c;
                }
                k++;//берем k на 1 больше(увеличиваем степень) и вновь повторяем цикл
            } while (pow(2, k) * (pow(2, k + 1) - 1) < n);//но если число с становится больше или равно числу n, цикл (перебор чисел) прекращается
        }
        bool r = true;//введем новую переменную для цикла с запросом на выход или на продолжение
        while (r)
        {
            cout << "\nContinue?(Y/N)>";
            char a;
            while (!(cin >> a) || (cin.peek() != '\n') || (a != 'Y') && (a != 'y') && (a != 'N') && (a != 'n'))//если пользователь вводит 
            //любой другой символ (или комбинацию символов) кроме Y(y) N(n), то его просят ввести только эти (корректные) значения            
            {
                cin.clear();
                while (cin.get() != '\n');
                cout << "You entered a different sign!\nTry again?(Y/N)>";
            }
            if (a == 'y' || a == 'Y')
            {
                r = false;//если пользователь желает продолжить, то мы выходим из внутреннего цикла и возвращаемся в начало основного (внешнего) цикла
            }
            else if (a == 'n' || a == 'N')
            {
                r = false;//если пользователь желает выйти, то мы выходим сразу из внутреннего и внешнего цикла
                t = false;
            }
        }
    }
    return 0;//программа корректно завершается
}