#include <iostream>
#include <fstream>

//сортировка двусвязного списка пирамидальной сортировкой или сортировкой выбором

using namespace std;

struct list
{
	int val;							//значение ячейки
	list* prev;							//указатель на предыдущую ячейку (если она есть)
	list* next;							//указатель на следующую ячейку (если она есть)
};

void get_head_back(list*& head)			//функция для возвращения указателя на начало (голову) списка
{

	while (head->prev != NULL)
	{
		head = head->prev;
	}

}

void push_back(list*& head, int a)		//получененные значения помещаем в конец списка
{
	list* t = new list;
	t->val = a;
	t->next = NULL;
	t->prev = head;

	if (head)
	{
		head->next = t;					//если элемент не первый в списке, то соединяем его с предыдущей ячейкой
	}

	head = t;							//перемещаем голову на последний элемент, чтобы добавить еще (если они есть)

}

void swap(list* rep, list* head)		//replaceable элемент всегда находится ПОСЛЕ головы для корректной работы обмена
{
	list* t = new list;					//временная переменная для обмена

	t = rep->prev;						//сначала меняются указатели на предыдущие элементы двух меняемых ячеек
	rep->prev = head->prev;

	if (t == head)						//если элементы соседние (пункт обязательный, т.к. создаются петли, если тупо менять prev и next)
	{
		t = rep;
	}

	head->prev = t;

	t = head->next;						//затем меняем указатели на последующие элементы двух меняемыъ ячеек
	head->next = rep->next;

	if (t == rep)						//также проверяется: соседние ли элементы
	{
		t = head;
	}

	rep->next = t;

	rep->next->prev = rep;				//абсолютно во всех ситуацих после обмена у меняемого будет ПОСЛЕДУЮЩИЙ элемент, а у головы ПРЕДЫДУЩИЙ
	head->prev->next = head;
	if (rep->prev)						//а будут ли у них два других соседних элемента - неизвестно. поэтому необходимо случаи эти проверить
	{
		rep->prev->next = rep;
	}

	if (head->next)
	{
		head->next->prev = head;
	}

}


void selection_sort(list* head)			//сортировка выбором
{
	while (head->next != NULL)			//если элемент НЕ единственный в списке, то имеет смысл его сортировать
	{									//сортировка продолжается, пока мы не достигнем последеней ячейки в списке. сравнивать её не с чем, поэтому сортировка будет завершена
		list* min = head;				//за минимальный элемент пока что принимаем голову
		list* t = head;					//t будет идти по всем оставшимся элементам и проходить проверку: меньше ли значение в ячейке t наименьшего в списке?
		do
		{
			t = t->next;				//сразу после головы переходим к следующей ячейке
			if (t->val < min->val)		//если значение ячейки t меньше значения ячейки min
			{
				min = t;				//то ячейка t становится ячейкой с минимальным значением в ней
			}
		} while (t->next != NULL);		//продолжаем проходиться по списку, пока ячейка t не окажется последней в нем

		if (head != min)				//если min поменялось, то меняем значения головы и ячейки, в которой находится самое минимальное значение
		{
			swap(min, head);
		}

		head = min->next;				//головой становится СЛЕДУЮЩИЙ после самого минимального, ну либо просто следующий, если голова и была ячейкой с минимальным значением в ней
	}
}



//// Основная функция, выполняющая пирамидальную сортировку
//void heapSort(int arr[], int n)
//{
//	// Построение кучи (перегруппируем массив)
//	for (int i = n / 2 - 1; i >= 0; i--)
//		heapify(arr, n, i);
//
//	// Один за другим извлекаем элементы из кучи
//	for (int i = n - 1; i >= 0; i--)
//	{
//		// Перемещаем текущий корень в конец
//		swap(arr[0], arr[i]);
//
//		// вызываем процедуру heapify на уменьшенной куче
//		heapify(arr, i, 0);
//	}
//}


///////////////////////////////////////////////////////////////////////

void heap_limb(list* head, int n, int i)
{
	int large = i;								//корень (узел)

	list* largest = head;						//инициализируем ячейку с наибольшим значением как корень

	int l = 2 * i + 1;							//левая ветвь = 2*i + 1

	list* left = head;
	if (l < n)									//имеет смысл искать левую ветвь если порядковый номер ее будет меньше, чем количество элементов в древе
	{
		for (int j = 0; j < i + 1; j++)			//так как индекс левой ветви 2*i + 1, то ,идя от корня i, необходимо осуществить 2i+1-i итераций = i+1
		{
			left = left->next;
		}
	}

	int r = 2 * i + 2;							//правая ветвь = 2*i + 2

	list* right = head;
	if (r < n)									//аналогично, как и с левой ветвью, не имеет смысла искать ветвь, если её номер количества элементов в древе
	{
		for (int j = 0; j < i + 2; j++)			//аналогично, как и с левой ветвью, но нужно пройти i+2
		{
			right = right->next;
		}
	}

	//если левый дочерний элемент больше корня
	if (l < n && left->val > largest->val)
	{
		largest = left; large = l;
	}

	//если правый дочерний элемент больше, чем самый большой элемент на данный момент
	if (r < n && right->val > largest->val)
	{
		largest = right; large = r;
	}

	if (largest != head)						//если мы нашли элемент, больше корня
	{
		swap(largest, head);					//меняем их местами

		heap_limb(head, n, large);				//теперь за корень (или узел) берём уже бывшую голову (которая находится теперь на месте дочерней ветви)
												//и повторяем
	}
}


void heap_sort(list* head, int n)
{
	int i = n / 2 - 1;							//находим самый нижний правый узел

	for (int j = 0; j < i; j++)					//передвигаем указатель головы на этот узел (корень)
	{
		head = head->next;
	}

	heap_limb(head, n, i);						//вызываем первый узел и если он не единственный, то следуем к следующим (с конца)

	for (--i; i >= 0; i--)						//переходим к следующему узлу
	{
		get_head_back(head);					//т.к. значения все время перезаписываться, в переменной head (может так получиться) будет храниться не всегда необходимый узел
												//поэтому для корректной работы алгоритма необходимо вернуться в начало списка
		for (int j = 0; j < i; j++)				//и спокойной дойти до необходимого узла
		{
			head = head->next;
		}

		heap_limb(head, n, i);
	}

	for (int i = n - 1; i > 0; i--)				//поочередно, одним за другим извлекаем элементы
	{

		get_head_back(head);					//head постоянно перезаписывается и используется, поэтому необходимо каждый раз возвращаться в начало
		list* temp = head;						//также меняются и значения temp. тоже возвращаем его в начало списка и честно проходимся до нужного нам элемента

		for (int j = 0; j < i; j++)
		{
			temp = temp->next;
		}

		swap(temp, head);						//перемещаем текущий корень (самый верхний узел) в конец, т.к. в нём хранится максимальный элемент

		list* l = head;							//меняем местами значения головы и temp
		head = temp;
		temp = l->prev;							//т.к. мы постепенно убиваем ветви в древе, то temp будет указывать уже на предшествующий концу элементы

		heap_limb(head, i, 0);					//вызываем функцию уже на уменьшенном древе
	}
}

void output(ostream& fout, list*& head, int n)
{
	fout << n << ' ';						//помещаем в файл кол-во элементов
	if (head)
	{
		while (head->next != NULL)			//идем по списку пока не наткнёмся на последнюю ячейку
		{

			fout << head->val << ' ';		//выводим значение ячейки
			head = head->next;				//переходим к следующей (т.к. мы уже проверили, что последующая точно есть)
		}
		fout << head->val;					//если ячейка последняя, выводим её значение и выходим из функции
	}
}



int main()
{
	int n = 0;								//количество элементов в списке
	int a;									//переменная val
	int d;									//метод сортировки (0 - пирамида, 1 - выбор)
	list* head = NULL;						//адрес на ячейку головы
	ifstream fin("input.txt");
	ofstream fout("output.txt");

	if (fin.is_open() && fout.is_open())
	{
		fin >> d;
		while (!fin.eof())					//пока элементы в файле не закончатся, пуш бэком добавляем элементы в конец списка
		{
			fin >> a;						//читаем значение
			push_back(head, a);				//передаем ссылку на голову и значение
			n++;							//увеличиваем счётчик кол-ва элементов
		}

		if (n)								//если вдруг файл пустой! просто помещаем в файл количество элементов равное нулю, закрываем файлы и завершаем работу
		{

			get_head_back(head);			//возвращаемся в начало списка

			if (d)							//если 1, то сортировка выбором
			{
				selection_sort(head);
			}

			else							//если 0, то сортировка пирамидой
			{
				heap_sort(head, n);
			}

			get_head_back(head);			//после завершения сортировки возвращаем голову

		}

		output(fout, head, n);				//помещаем отсортированный список в файл	

		fout.close();						//закрываем файл, куда записывали
		fin.close();						//и откуда читали
	}

	else return -1;							//если какой-либо из файлов не открылся, то завершаем работу с -1

	return 0;								//если всё прошло корректно, завершаем работу
}